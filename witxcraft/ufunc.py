#!/usr/bin/env python3

"""
Wrap WASM functions for use in pandas / Dask

The `witx-bindgen` utility allows you to create wrappers around
WASM functions in order to expand the usable parameter and return
types of those functions. This module adds additional functions
to make it easy to use those WASM functions in the pandas
and Dask `DataFrame.apply` and `Series.apply` methods.

Example::

    # Import the witxcraft package.
    import witxcraft as wc

    # Create wrappers for all WASM functions in a module.
    # This will look for a file named `df.witx` with the function
    # signatures and input / output data types.
    wasm_funcs = wc.fromwasmfunc('df.wasm')

    # Use the function on a DataFrame
    df = pd.DataFrame([...], columns=[...])
    print(df['colname'].apply(wasm_funcs.my_func))

"""

import dataclasses
import inspect
import os
import pandas as pd
import re
import subprocess
import sys
import tempfile
import textwrap
import typing
import urllib.request
import wasmtime
from numpy import frompyfunc
from types import ModuleType
from typing import Union, Any, BinaryIO, Mapping, Optional


class WASMUFunc(object):
    """
    Wrapper for WASM function to make it compatible with `pandas.DataFrame/Series.apply`

    Parameters
    ----------
    wasm : bytes or str
        Contents of WASM module (either compiled or text format).
    exports : str
        Code generated by `witx-bindgen` that contains WASM function definitions.
    func_name : str
        Name of the function from `exports` to wrap.

    """

    def __init__(self, wasm: Union[bytes, str], exports: str, func_name: str):
        self.wasm = wasm
        self.exports = exports
        self.name = func_name
        self.ret_meta = {}
        self._store = None
        self._func = None
        self._ufunc = {}
        self._ret_is_record = False
        self._is_vector_func = False

    @property
    def __doc__(self):
        return self._ufunc.get("__doc__", "")

    @property
    def __name__(self):
        return self._ufunc["__name__"]

    @property
    def nin(self):
        return self._ufunc.get("nin", 1)

    @property
    def nout(self):
        return self._ufunc.get("nout", 1)

    @property
    def nargs(self):
        # Must be at least one value, out=, and dtype=.
        return self._ufunc.get("nargs", 3)

    @property
    def ntypes(self):
        return len(self._ufunc["types"])

    @property
    def types(self):
        #
        # https://numpy.org/devdocs/reference/arrays.scalars.html#built-in-scalar-types
        #
        # i -> int32
        # l -> int64
        # f -> float32
        # d -> float64
        #
        # Example: ['ii->i']
        #
        return self._ufunc["types"]

    @property
    def identity(self):
        return self._ufunc.get("identity")

    @property
    def signature(self):
        # https://numpy.org/devdocs/reference/generated/numpy.ufunc.signature.html
        return self._ufunc.get("signature")

    def __call__(self, *args, **kwargs):
        """ Call the wrapped WASM function """
        if self._func is None:
            self._func = self._init_func()

        # Vector functions should be passed the entire vector of input values.
        if self._is_vector_func:
            out = self._func(*args)
            if (
                self._ret_is_record
                and hasattr(out, "head")
                and not hasattr(out, "columns")
            ):
                out = pd.DataFrame(list(out))
            else:
                out = pd.Series(out)

        # TODO: Handle this natively to allow pickling.
        elif getattr(args[0], "__array_ufunc__", None) is not None:
            out = frompyfunc(self, self.nin, self.nout)(*args, **kwargs)
            # TODO: If the function is returning a Series of Series, we want
            #       to make it into a DataFrame. However, if it returns a
            #       DataFrame, we leave it alone. There is probably a better
            #       way to do this.
            if (
                self._ret_is_record
                and hasattr(out, "head")
                and not hasattr(out, "columns")
            ):
                out = pd.DataFrame(list(out))

        else:
            out = self._func(*args)

        return out

    def __getstate__(self):
        """ Custom pickling method to remove non-picklable fields """
        state = vars(self)
        state["_func"] = None
        state["_store"] = None
        return state

    def __setstate__(self, d):
        """ Restore state (usually from pickling) """
        self.__dict__ = d

    def _init_func(self):
        """
        Initialize a WASM module of functions and create ufunc

        Returns
        -------
        WASMUFunc

        """
        self._store = wasmtime.Store()

        module = wasmtime.Module(self._store.engine, self.wasm)

        linker = wasmtime.Linker(self._store.engine)
        linker.define_wasi()

        wasi = wasmtime.WasiConfig()
        wasi.inherit_stdout()
        wasi.inherit_stderr()
        self._store.set_wasi(wasi)

        # Execute bindings code to retrieve generated functions and types.
        exports = _get_exports(self.exports)

        func = getattr(exports["exports"](self._store, linker, module), self.name)

        arg_spec = inspect.getfullargspec(func)

        self._init_ufunc_info(arg_spec)

        ann = arg_spec.annotations
        arg_spec = arg_spec.args[2:]
        ret_type = ann["return"]
        arg_types = [ann[x] for x in arg_spec]

        assert len(arg_types), "No function arguments were specified."

        ret_index = None
        if dataclasses.is_dataclass(ret_type):
            ret_index = [x.name for x in dataclasses.fields(ret_type)]
            self.ret_meta = {x.name: x.type for x in dataclasses.fields(ret_type)}
            self._ret_is_record = True
        else:
            self.ret_meta = ("", ret_type)
            self._ret_is_record = False

        # If the arg_type is a dataclass, use the record conversion functions.
        # This mode assumes that a row of data should be sent to the function.
        arg_index = None
        if dataclasses.is_dataclass(arg_types[0]):
            arg_index = [x.name for x in dataclasses.fields(arg_types[0])]

        # Functions that take vectors should not be treated as ufuncs. They need to
        # to take the entire vector as an input argument.
        # TODO: issubclass(arg_types[0], List) does not work here.
        elif "List" in str(arg_types[0]):
            self._is_vector_func = True

        def wasm_func(*args):

            # Input is a record.
            if arg_index is not None:
                assert len(args) == len(arg_index), (
                    "Number of arguments ({}) does not match number of fields "
                    "in input record ({}).".format(args, ", ".join(arg_index))
                )
                out = func(self._store, arg_types[0](**dict(zip(arg_index, args))))

            # Input is not a record
            else:
                assert len(args) == len(arg_types), (
                    "Number of arguments ({}) does not match number of arguments "
                    "of WASM function ({}).".format(args, ", ".join(arg_spec))
                )
                out = func(self._store, *args)

            # Return value is a record.
            if ret_index is not None:
                return pd.Series(dataclasses.astuple(out), index=ret_index)

            return out

        return wasm_func

    def _init_ufunc_info(self, arg_spec):
        _ufunc = self._ufunc
        _ufunc["__name__"] = self.name
        _ufunc["nin"] = len(arg_spec.args[2:])
        _ufunc["nout"] = 1  # TODO: Support multiple outputs?
        _ufunc.get("nargs", _ufunc["nin"] + 2)  # Add out= and dtype=.
        # https://numpy.org/devdocs/reference/arrays.scalars.html#built-in-scalar-types
        _ufunc["types"] = ["??->?"]  # TODO: See if this can be generated.
        _ufunc["ntypes"] = len(_ufunc["types"])


def fromwasmmod(
    wasm: Union[str, bytes, BinaryIO], witx: Optional[str] = None
) -> ModuleType:
    """
    Construct module of WASM functions for use in `DataFrame` methods

    wasm : str or bytes or BinaryIO
        Content or location of WASM module.
    witx : str, optional
        Content or location of WITX file. By default, a WITX file with the same
        basename and location as the WASM file is searched for.

    Returns
    -------
    Module
        A new module with callables for each WASM function in the input module.

    """
    wasm, witx = _read_wasm(wasm, witx=witx)

    # Generate witx-bindgen bindings files.

    with tempfile.TemporaryDirectory() as temp_dir:
        exports_witx = os.path.join(temp_dir, "exports.witx")
        with open(exports_witx, "w") as witx_file:
            witx_file.write(witx)

        try:
            subprocess.check_call(
                ["witx-bindgen", "--help"],
                stdin=subprocess.DEVNULL,
                stdout=subprocess.DEVNULL,
            )
        except (FileNotFoundError, subprocess.CalledProcessError):
            print(
                "witx-bindgen must be installed to use this package.", file=sys.stderr
            )
            print(
                "See https://github.com/bytecodealliance/witx-bindgen#installation"
                " for details.",
                file=sys.stderr,
            )
            return

        subprocess.check_call(
            [
                "witx-bindgen",
                "wasmtime-py",
                "--export",
                exports_witx,
                "--out-dir",
                temp_dir,
            ]
        )

        with open(os.path.join(temp_dir, "bindings.py"), "r") as bindings_file:
            bindings_code = bindings_file.read()
            bindings = _get_exports(bindings_code)

    # Construct a new module for exported functions.
    out = ModuleType("exports")

    # Wrap all WASM functions.
    for name, value in vars(bindings["exports"]).items():
        if not callable(value) or name.startswith("_"):
            continue
        setattr(out, name, WASMUFunc(wasm, bindings_code, name))

    return out


def _read_wasm(
    wasm: Union[str, bytes, BinaryIO], witx: Union[str, bytes, BinaryIO, None]
):
    """
    Read WASM content in various forms

    Parameters
    ----------
    wasm : str or bytes or BinaryIO
        The WASM content or path to it.
    witx : str or bytes or BinaryIO or None
        The WITX content or path to it.

    Returns
    -------
    Tuple[Union[bytes, str], str]
        Contents of WASM file and WITX file.

    """
    if witx is not None:
        witx = _read_witx(witx)

    if hasattr(wasm, "read"):
        wasm = wasm.read()
    elif isinstance(wasm, str) and re.match(r"^\s*(https?|s?ftp)://", wasm):
        with urllib.request.urlopen(wasm, "rb") as wasm_url:
            if witx is None:
                witx = _read_witx(re.sub(r"\.\w+$", r"\.witx", wasm_url))
            wasm = wasm_url.read()
    elif isinstance(wasm, str) and os.path.isfile(wasm):
        with open(wasm, "rb") as wasm_file:
            if witx is None:
                witx = _read_witx(re.sub(r"\.\w+$", r".witx", wasm))
            wasm = wasm_file.read()

    if witx is None:
        raise FileNotFoundError("Could not locate WITX file.")

    return wasm, witx


def _read_witx(witx: Union[str, bytes, BinaryIO]):
    """
    Read WITX file contents

    Parameters
    ----------
    witx : str or bytes or BinaryIO
        Location or content of WITX file.

    Returns
    -------
    str
        WITX content

    """
    if hasattr(witx, "read"):
        witx = witx.read()
    elif isinstance(witx, str) and re.match(r"\s*(https?|s?ftp)://", witx):
        with urllib.request.urlopen(witx, "r") as witx_url:
            witx = witx_url.read()
    elif isinstance(witx, str) and os.path.isfile(witx):
        with open(witx, "r") as witx_file:
            witx = witx_file.read()
    return witx


def _get_exports(code: str) -> Mapping[str, Any]:
    """
    Execute bindings code and retrieve functions class and types

    Parameters
    ----------
    code : str
        Code from the `witx-bindgen` generated bindings.

    Returns
    -------
    dict
        The 'exports' key contains the class of WASM functions.
        The 'types' key contains a dictionary of WITX types used in the functions.

    """
    locs = {}
    text = "\n".join(
        ["def wasm_bindings():\n", textwrap.indent(code, "    "), "    return locals()"]
    )
    exec(text, {}, locs)

    locs = locs["wasm_bindings"]()

    out = dict(types={})

    # Get export class name.
    for ex_name, ex_value in locs.items():
        qualname = getattr(ex_value, "__qualname__", "")
        if not qualname.startswith("wasm_bindings."):
            continue
        if ex_name.startswith("_"):
            pass
        elif type(ex_value) is type and not dataclasses.is_dataclass(ex_value):
            hints = typing.get_type_hints(ex_value)
            if "instance" in hints and "_memory" in hints:
                out["exports"] = ex_value
            else:
                out["types"][ex_name] = ex_value
        else:
            out["types"][ex_name] = ex_value

    assert (
        "exports" in out
    ), "Could not find WASM bindings class in generated bindings file."

    return out
